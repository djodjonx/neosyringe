/**
 * E2E Tests - Container Integration
 *
 * These tests verify the container behavior by simulating
 * what the generated code does.
 */
import { describe, it, expect } from 'vitest';

describe('E2E - Container Integration', () => {
  /**
   * Simulates the generated NeoContainer class
   * This matches the structure generated by Generator.ts
   */
  class NeoContainer {
    private instances = new Map<any, any>();

    constructor(
      private parent?: any,
      private legacy?: any[],
      private name: string = 'TestContainer'
    ) {}

    private factories = new Map<any, (container: NeoContainer) => any>();

    registerFactory(token: any, factory: (container: NeoContainer) => any, lifecycle: 'singleton' | 'transient' = 'singleton') {
      if (lifecycle === 'transient') {
        this.factories.set(token, (c) => factory(c));
      } else {
        this.factories.set(token, (c) => {
          if (!this.instances.has(token)) {
            this.instances.set(token, factory(c));
          }
          return this.instances.get(token);
        });
      }
    }

    resolve<T>(token: any): T {
      // Try local
      if (this.factories.has(token)) {
        return this.factories.get(token)!(this);
      }

      // Try parent
      if (this.parent && typeof this.parent.resolve === 'function') {
        try {
          return this.parent.resolve(token);
        } catch {
          // Continue to legacy
        }
      }

      // Try legacy
      if (this.legacy) {
        for (const container of this.legacy) {
          try {
            return container.resolve(token);
          } catch {
            // Continue
          }
        }
      }

      throw new Error(`[${this.name}] Service not found: ${token?.name || token}`);
    }
  }

  describe('Basic Resolution', () => {
    it('should resolve a simple service', () => {
      class SimpleService {
        getValue() { return 42; }
      }

      const container = new NeoContainer();
      container.registerFactory(SimpleService, () => new SimpleService());

      const service = container.resolve<any>(SimpleService);
      expect(service.getValue()).toBe(42);
    });

    it('should resolve service with dependencies', () => {
      class Logger {
        logs: string[] = [];
        log(msg: string) { this.logs.push(msg); }
      }

      class UserService {
        constructor(private logger: Logger) {}
        greet(name: string) {
          this.logger.log(`Hello ${name}`);
          return `Hello ${name}`;
        }
      }

      const container = new NeoContainer();
      container.registerFactory(Logger, () => new Logger());
      container.registerFactory(UserService, (c) => new UserService(c.resolve(Logger)));

      const userService = container.resolve<any>(UserService);
      expect(userService.greet('World')).toBe('Hello World');
    });
  });

  describe('Singleton Scope', () => {
    it('should return same instance for singleton', () => {
      class Counter {
        count = 0;
        increment() { return ++this.count; }
      }

      const container = new NeoContainer();
      container.registerFactory(Counter, () => new Counter(), 'singleton');

      const c1 = container.resolve<any>(Counter);
      const c2 = container.resolve<any>(Counter);

      expect(c1).toBe(c2);
      expect(c1.increment()).toBe(1);
      expect(c2.increment()).toBe(2); // Same instance!
    });
  });

  describe('Transient Scope', () => {
    it('should return different instances for transient', () => {
      let instanceId = 0;
      class Transient {
        id: number;
        constructor() { this.id = ++instanceId; }
      }

      const container = new NeoContainer();
      container.registerFactory(Transient, () => new Transient(), 'transient');

      const t1 = container.resolve<any>(Transient);
      const t2 = container.resolve<any>(Transient);

      expect(t1).not.toBe(t2);
      expect(t1.id).not.toBe(t2.id);
    });
  });

  describe('Deep Dependency Chain', () => {
    it('should resolve complex graph correctly', () => {
      class Config { dbUrl = 'postgres://localhost'; }
      class Logger { log(m: string) { return `[LOG] ${m}`; } }
      class Database {
        constructor(public config: Config, public logger: Logger) {}
        query() { return this.config.dbUrl; }
      }
      class UserRepo {
        constructor(public db: Database) {}
        find() { return this.db.query(); }
      }
      class UserService {
        constructor(public repo: UserRepo, public logger: Logger) {}
        getDbUrl() { return this.repo.find(); }
      }

      const container = new NeoContainer();
      container.registerFactory(Config, () => new Config());
      container.registerFactory(Logger, () => new Logger());
      container.registerFactory(Database, (c) => new Database(c.resolve(Config), c.resolve(Logger)));
      container.registerFactory(UserRepo, (c) => new UserRepo(c.resolve(Database)));
      container.registerFactory(UserService, (c) => new UserService(c.resolve(UserRepo), c.resolve(Logger)));

      const userService = container.resolve<any>(UserService);
      expect(userService.getDbUrl()).toBe('postgres://localhost');

      // Verify singleton behavior
      const logger1 = container.resolve<any>(Logger);
      const logger2 = userService.logger;
      expect(logger1).toBe(logger2);
    });
  });

  describe('Error Handling', () => {
    it('should throw clear error for unknown token', () => {
      class Registered {}
      class NotRegistered {}

      const container = new NeoContainer(undefined, undefined, 'MyApp');
      container.registerFactory(Registered, () => new Registered());

      expect(() => container.resolve<any>(NotRegistered)).toThrow(/MyApp.*not found/);
    });
  });

  describe('Diamond Dependency Pattern', () => {
    it('should share singleton across diamond', () => {
      class Shared { id = Math.random(); }
      class Left { constructor(public shared: Shared) {} }
      class Right { constructor(public shared: Shared) {} }
      class Top { constructor(public left: Left, public right: Right) {} }

      const container = new NeoContainer();
      container.registerFactory(Shared, () => new Shared());
      container.registerFactory(Left, (c) => new Left(c.resolve(Shared)));
      container.registerFactory(Right, (c) => new Right(c.resolve(Shared)));
      container.registerFactory(Top, (c) => new Top(c.resolve(Left), c.resolve(Right)));

      const top = container.resolve<any>(Top);

      // Both Left and Right should share the same Shared instance
      expect(top.left.shared).toBe(top.right.shared);
      expect(top.left.shared.id).toBe(top.right.shared.id);
    });
  });

  describe('Parent Container', () => {
    it('should delegate to parent for missing tokens', () => {
      class SharedService { value = 'shared'; }
      class ChildService { constructor(public shared: SharedService) {} }

      const parent = new NeoContainer(undefined, undefined, 'Parent');
      parent.registerFactory(SharedService, () => new SharedService());

      const child = new NeoContainer(parent, undefined, 'Child');
      child.registerFactory(ChildService, (c) => new ChildService(c.resolve(SharedService)));

      const service = child.resolve<any>(ChildService);
      expect(service.shared.value).toBe('shared');
    });

    it('should use child token over parent token', () => {
      class Service { value: string; constructor(v: string) { this.value = v; } }

      const parent = new NeoContainer();
      parent.registerFactory(Service, () => new Service('parent'));

      const child = new NeoContainer(parent);
      child.registerFactory(Service, () => new Service('child'));

      expect(child.resolve<any>(Service).value).toBe('child');
    });
  });

  describe('Legacy Container', () => {
    it('should delegate to legacy container', () => {
      class LegacyService { fromLegacy = true; }

      // Mock legacy container (like tsyringe)
      const legacyContainer = {
        resolve: (token: any) => {
          if (token === LegacyService) return new LegacyService();
          throw new Error('Not found');
        }
      };

      const container = new NeoContainer(undefined, [legacyContainer], 'App');

      const service = container.resolve<any>(LegacyService);
      expect(service.fromLegacy).toBe(true);
    });

    it('should try local first, then legacy', () => {
      class Service { source: string; constructor(s: string) { this.source = s; } }

      const legacyContainer = {
        resolve: () => new Service('legacy')
      };

      const container = new NeoContainer(undefined, [legacyContainer]);
      container.registerFactory(Service, () => new Service('local'));

      expect(container.resolve<any>(Service).source).toBe('local');
    });
  });

  describe('Interface-like Tokens (Strings)', () => {
    it('should resolve string tokens', () => {
      class ConsoleLogger {
        log(msg: string) { return `[LOG] ${msg}`; }
      }

      const container = new NeoContainer();
      const ILOGGER_TOKEN = 'ILogger';

      container.registerFactory(ILOGGER_TOKEN, () => new ConsoleLogger());

      const logger = container.resolve<ConsoleLogger>(ILOGGER_TOKEN);
      expect(logger.log('test')).toBe('[LOG] test');
    });

    it('should resolve dependencies using string tokens', () => {
      class ConsoleLogger { log(m: string) { return m; } }
      class UserService { constructor(public logger: ConsoleLogger) {} }

      const container = new NeoContainer();
      const ILOGGER = 'ILogger';

      container.registerFactory(ILOGGER, () => new ConsoleLogger());
      container.registerFactory(UserService, (c) => new UserService(c.resolve(ILOGGER)));

      const service = container.resolve<any>(UserService);
      expect(service.logger.log('hi')).toBe('hi');
    });
  });

  describe('Factory Providers', () => {
    it('should execute factory with container access', () => {
      class Config { env = 'test'; }

      const container = new NeoContainer();
      container.registerFactory(Config, () => new Config());

      const API_URL_TOKEN = 'ApiUrl';
      container.registerFactory(API_URL_TOKEN, (c) => {
        const config = c.resolve<Config>(Config);
        return `https://api.${config.env}.example.com`;
      });

      expect(container.resolve<any>(API_URL_TOKEN)).toBe('https://api.test.example.com');
    });
  });

  describe('Performance', () => {
    it('should handle 100 singleton resolutions efficiently', () => {
      class HeavyService {
        data = Array.from({ length: 1000 }, () => 0);
      }

      const container = new NeoContainer();
      container.registerFactory(HeavyService, () => new HeavyService());

      const start = Date.now();
      for (let i = 0; i < 100; i++) {
        container.resolve<any>(HeavyService);
      }
      const duration = Date.now() - start;

      // Should be very fast since it's singleton
      expect(duration).toBeLessThan(50); // 50ms max
    });

    it('should handle deep resolution chain', () => {
      const container = new NeoContainer();

      // Create 20 levels of dependencies
      class L0 {}
      container.registerFactory(L0, () => new L0());

      let prevClass: any = L0;
      for (let i = 1; i <= 20; i++) {
        const CurrentClass = class { constructor(public dep: any) {} };
        const prev = prevClass;
        container.registerFactory(CurrentClass, (c) => new CurrentClass(c.resolve(prev)));
        prevClass = CurrentClass;
      }

      const start = Date.now();
      container.resolve<any>(prevClass);
      const duration = Date.now() - start;

      expect(duration).toBeLessThan(100); // 100ms max for 20 levels
    });
  });
});

